---

title: Supervised criteria


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/criteria/1_supervised_criteria.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/criteria/1_supervised_criteria.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SupervisedCriterion" class="doc_header"><code>class</code> <code>SupervisedCriterion</code><a href="dl4to/criteria.py#L200" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SupervisedCriterion</code>(<strong><code>name</code></strong>:<code>str</code>, <strong><code>differentiable</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>lower_is_better</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tocriteria.html#Criterion"><code>Criterion</code></a></p>
</blockquote>
<p>A parent class that inherits all supervised criteria for both classical and learned methods.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>name</code></strong></td>
<td><code>str</code></td>
<td></td>
<td>The name of this criterion which will be monitored in logging.</td>
</tr>
<tr>
<td><strong><code>differentiable</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion is differentiable or not. Only differentiable criteria can be used as loss/objective functions.</td>
</tr>
<tr>
<td><strong><code>lower_is_better</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether lower values of the criterion correspond to better scores.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="SupervisedCriterion.__call__" class="doc_header"><code>SupervisedCriterion.__call__</code><a href="dl4to/criteria.py#L274" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>SupervisedCriterion.__call__</code>(<strong><code>solutions</code></strong>:<code>list</code>, <strong><code>gt_solutions</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>binary</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>Calculates the output of the criterion for all solutions.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>solutions</code></strong></td>
<td><code>list</code></td>
<td></td>
<td>The solutions that should be evaluated with the criterion.</td>
</tr>
<tr>
<td><strong><code>gt_solutions</code></strong></td>
<td><code>list</code></td>
<td><code>None</code></td>
<td>Ground truth solutions that are compared element-wise with the <code>solutions</code>.</td>
</tr>
<tr>
<td><strong><code>binary</code></strong></td>
<td><code>bool</code></td>
<td><code>False</code></td>
<td>Whether the criterion should be evaluated on binarized densities. Does not have an effect on some criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="WeightedBCE" class="doc_header"><code>class</code> <code>WeightedBCE</code><a href="dl4to/criteria.py#L285" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>WeightedBCE</code>(<strong><code>weight</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>Weighted Binary cross entropy [1] is a variant of binary cross entropy variant. The weight value can be used to tune false negatives and false positives.
E.g; If you want to reduce the number of false negatives then set weight &gt; 1, similarly to decrease the number of false positives, set weight &lt; 1.
The criterion reaches its best value at 0 and higher values correspond to worse scores.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>weight</code></strong></td>
<td><code>float</code></td>
<td><code>0.5</code></td>
<td>The weight of the weighted binary cross entropy function which is used to take class imbalance into account.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="WeightedBCE.set_optimal_weight" class="doc_header"><code>WeightedBCE.set_optimal_weight</code><a href="dl4to/criteria.py#L302" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>WeightedBCE.set_optimal_weight</code>(<strong><code>dataset</code></strong>:<code>dl4to.dataset.TopoDataset</code>, <strong><code>binary</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>Calculates the optimal BCE weight based on the solutions in the dataset.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>dataset</code></strong></td>
<td><code>dl4to.dataset.TopoDataset</code></td>
<td></td>
<td>The dataset based on which the optimal weight is determined.</td>
</tr>
<tr>
<td><strong><code>binary</code></strong></td>
<td><code>bool</code></td>
<td><code>False</code></td>
<td>Whether the densities in the solutions are thresholded at 0.5 before the weight is determined.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="WeightedFocal" class="doc_header"><code>class</code> <code>WeightedFocal</code><a href="dl4to/criteria.py#L339" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>WeightedFocal</code>(<strong><code>weight</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>γ</code></strong>:<code>float</code>=<em><code>3</code></em>, <strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>Focal loss [2] can be seen as variation of Binary Cross-Entropy. It down-weights the contribution of easy examples and enables the model to focus more on learning hard examples.
It works well for highly imbalanced class scenarios. The criterion reaches its best value at 0 and higher values correspond to worse scores.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>weight</code></strong></td>
<td><code>float</code></td>
<td><code>0.5</code></td>
<td>The weight of the weighted focal function which is used to take class imbalance into account.</td>
</tr>
<tr>
<td><strong><code>γ</code></strong></td>
<td><code>float</code></td>
<td><code>3</code></td>
<td>$γ\geq0$ is the tunable focusing parameter. Setting $γ&gt;0$ reduces the relative loss for well-classified examples, putting more focus on hard, misclassified examples.</td>
</tr>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="WeightedFocal.set_optimal_weight" class="doc_header"><code>WeightedFocal.set_optimal_weight</code><a href="dl4to/criteria.py#L359" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>WeightedFocal.set_optimal_weight</code>(<strong><code>dataset</code></strong>:<code>dl4to.dataset.TopoDataset</code>, <strong><code>binary</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>Calculates the optimal BCE weight based on the solutions in the dataset.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>dataset</code></strong></td>
<td><code>dl4to.dataset.TopoDataset</code></td>
<td></td>
<td>The dataset based on which the optimal weight is determined.</td>
</tr>
<tr>
<td><strong><code>binary</code></strong></td>
<td><code>bool</code></td>
<td><code>False</code></td>
<td>Whether the densities in the solutions are thresholded at 0.5 before the weight is determined.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Dice" class="doc_header"><code>class</code> <code>Dice</code><a href="dl4to/criteria.py#L399" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Dice</code>(<strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The Dice coefficient is widely used metric in computer vision community to calculate the similarity between two images.
Later in 2016, it has also been adapted as loss function known as Dice Loss [3]. It is also sometimes refered to as the F1 score [4].
Dice reaches its best value at 0 and its worst value at 1.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Tversky" class="doc_header"><code>class</code> <code>Tversky</code><a href="dl4to/criteria.py#L438" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Tversky</code>(<strong><code>α</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>Tversky index [5] can be seen as a generalization of the Dice coefficient. It adds a weight to false positives and false negatives. By setting the value of α &gt; 0.5, we can penalise false negatives more.
This becomes useful in highly imbalanced datasets where the additional level of control over the loss function yields better small scale segmentations than the normal dice coefficient.
Just like dice, this criterion reaches its best value at 0 and its worst value at 1.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>α</code></strong></td>
<td><code>float</code></td>
<td><code>0.5</code></td>
<td>The Tversky weight. When $α=0.5$, it can be solved into the regular Dice coefficient.</td>
</tr>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="FocalTversky" class="doc_header"><code>class</code> <code>FocalTversky</code><a href="dl4to/criteria.py#L480" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>FocalTversky</code>(<strong><code>α</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>γ</code></strong>:<code>float</code>=<em><code>3</code></em>, <strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The Focal Tversky Loss [6] is a generalisation of the Tversky loss. The non-linear nature of the loss gives control over how the loss behaves at different values of the Tversky index obtained.
Similar to Focal Loss, which focuses on hard examples by down-weighting easy ones. Focal Tversky loss  also attempts to learn hard-examples such with the help of γ, which controls the non-linearity of the loss.
This criterion reaches its best value at 0, while higher values correspond to worse scores.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>α</code></strong></td>
<td><code>float</code></td>
<td><code>0.5</code></td>
<td>The Tversky weight. When $α=0.5$, it can be solved into the regular Dice coefficient.</td>
</tr>
<tr>
<td><strong><code>γ</code></strong></td>
<td><code>float</code></td>
<td><code>3</code></td>
<td>$γ\geq0$ is the Focal loss focusing parameter. Setting $γ&gt;0$ reduces the relative loss for well-classified examples, putting more focus on hard, misclassified examples.</td>
</tr>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="IoU" class="doc_header"><code>class</code> <code>IoU</code><a href="dl4to/criteria.py#L524" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>IoU</code>(<strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The Intersection over Union (IoU) metric, also referred to as the Jaccard index, is essentially a method to quantify the percent overlap between the target mask and our prediction output. This metric is closely related to the Dice coefficient which is often used as a loss function during training.
The IoU metric measures the number of pixels common between the target and prediction masks divided by the total number of pixels present across both masks.
IoU reaches its best value at 1 and its worst value at 0, i.e., higher values are better.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="VoxelAccuracy" class="doc_header"><code>class</code> <code>VoxelAccuracy</code><a href="dl4to/criteria.py#L563" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>VoxelAccuracy</code>(<strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The voxel accuracy loss is a three-dimensional version of the pixel accuracy loss [7]. It reports the percent of voxels which are correctly classified. This metric can sometimes provide misleading results when the class representation is small within the image, as the measure will be biased in mainly reporting how well you identify negative case (ie. where the class is not present).
Voxel accuracy reaches its best value at 1 and its worst value at 0, i.e., higher values are better.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BalancedVoxelAccuracy" class="doc_header"><code>class</code> <code>BalancedVoxelAccuracy</code><a href="dl4to/criteria.py#L601" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BalancedVoxelAccuracy</code>(<strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The balanced voxel accuracy loss [9] is a balanced version of the voxel accuracy criterion and can also be interpreted as a rescaled version of the "Youden index" [10]. That makes it a better metric to use with imbalanced data. It is defined as the average of recall obtained on each class.
The criterion reaches its best value at 1 and its worst value at 0, i.e., higher values are better.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="L2Accuracy" class="doc_header"><code>class</code> <code>L2Accuracy</code><a href="dl4to/criteria.py#L636" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>L2Accuracy</code>(<strong><code>ε</code></strong>:<code>float</code>=<em><code>1e-06</code></em>, <strong><code>compute_only_on_design_space</code></strong>:<code>bool</code>=<em><code>True</code></em>) :: <a href="/dl4tosupervised_criteria.html#SupervisedCriterion"><code>SupervisedCriterion</code></a></p>
</blockquote>
<p>The L2 accuracy loss [8] reports the root mean squared accuracy of the predictions. The criterion reaches its best value at 1 and its worst value at 0, i.e., higher values are better.</p>
<table>
<thead><tr>
<th></th>
<th>Type</th>
<th>Default</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>ε</code></strong></td>
<td><code>float</code></td>
<td><code>1e-06</code></td>
<td>A small value $&gt;0$ that avoids division by $0$ and therefore improves numerical stability.</td>
</tr>
<tr>
<td><strong><code>compute_only_on_design_space</code></strong></td>
<td><code>bool</code></td>
<td><code>True</code></td>
<td>Whether the criterion should be evaluated on voxels that have a design space information of -1, i.e., the voxels can be freely optimized. This parameter does not effect all criteria.</td>
</tr>
</tbody>
</table>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="References">References<a class="anchor-link" href="#References"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>[1] Pihur, Vasyl, Susmita Datta, and Somnath Datta. "Weighted rank aggregation of cluster validation measures: a monte carlo cross-entropy approach." Bioinformatics 23.13 (2007): 1607-1615</p>
<p>[2] Lin, Tsung-Yi, et al. "Focal loss for dense object detection." Proceedings of the IEEE international conference on computer vision. 2017.</p>
<p>[3] Sudre, Carole H., et al. "Generalised dice overlap as a deep learning loss function for highly unbalanced segmentations." Deep Learning in Medical Image Analysis and Multimodal Learning for Clinical Decision Support: Third International Workshop, DLMIA 2017, and 7th International Workshop, ML-CDS 2017, Held in Conjunction with MICCAI 2017, Québec City, QC, Canada, September 14, Proceedings 3. Springer International Publishing, 2017.</p>
<p>[4] Taha, Abdel Aziz, and Allan Hanbury. "Metrics for evaluating 3D medical image segmentation: analysis, selection, and tool." BMC medical imaging 15.1 (2015): 1-28.</p>
<p>[5] Salehi, Seyed Sadegh Mohseni, Deniz Erdogmus, and Ali Gholipour. "Tversky loss function for image segmentation using 3D fully convolutional deep networks." Machine Learning in Medical Imaging: 8th International Workshop, MLMI 2017, Held in Conjunction with MICCAI 2017, Quebec City, QC, Canada, September 10, 2017, Proceedings 8. Springer International Publishing, 2017.</p>
<p>[6] Abraham, Nabila, and Naimul Mefraz Khan. "A novel focal tversky loss function with improved attention u-net for lesion segmentation." 2019 IEEE 16th international symposium on biomedical imaging (ISBI 2019). IEEE, 2019.</p>
<p>[7] Long, Jonathan, Evan Shelhamer, and Trevor Darrell. "Fully convolutional networks for semantic segmentation." Proceedings of the IEEE conference on computer vision and pattern recognition. 2015.</p>
<p>[8] Banga, Saurabh, et al. "3d topology optimization using convolutional neural networks." arXiv preprint arXiv:1808.07440 (2018).</p>
<p>[9] Brodersen, K.H.; Ong, C.S.; Stephan, K.E.; Buhmann, J.M. (2010). The balanced accuracy and its posterior distribution. Proceedings of the 20th International Conference on Pattern Recognition, 3121-24.</p>
<p>[10] Youden, William J. "Index for rating diagnostic tests." Cancer 3.1 (1950): 32-35.</p>

</div>
</div>
</div>
</div>
 

