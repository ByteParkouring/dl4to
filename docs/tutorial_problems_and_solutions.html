---

title: Problems and solutions


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/tutorials/1_tutorial_problems_and_solutions.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/tutorials/1_tutorial_problems_and_solutions.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this tutorial you learn how to</p>
<ul>
<li>set up custom problems</li>
<li>define solutions to them</li>
<li>work with trivial solutions</li>
<li>plot problems and solutions</li>
<li>compute the displacements and von Mises stresses for solutions and how to plot them</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-Problem-class">The Problem class<a class="anchor-link" href="#The-Problem-class"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Custom-problem-objects">Custom problem objects<a class="anchor-link" href="#Custom-problem-objects"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this first lesson we explain how to use our DL4TO framework to generate custom TO problems. This is done via the Problem class, which contains all information of the underlying TO problem one intends to solve. 
We focus on isotropic materials that are linearly elastic. This comprises most common materials, e.g., including steel and aluminum. Since we perform optimization on structured grids, all information is either in scalar or in tensor form. This makes data compatible with DL applications since it allows for a shape-consistent tensor representation.</p>
<p>Let $(n_x, n_y, n_z)$ be the number of voxels in each spacial direction, i.e. the shape of the TO problem. We can create unique problem objects characterized by the following inputs:</p>
<ul>
<li><p>Scalar material properties that define the physical proporties of the underlying material. These include:</p>
<ul>
<li>Young's modulus $E&gt;0$</li>
<li>Poisson's ratio $\nu\in [0, 0.5]$</li>
<li>The yield stress $\sigma_{ys}&gt;0$</li>
</ul>
</li>
<li><p>A three-dimensional vector $h$ that defines the voxel sizes in meters in each direction.</p>
</li>
<li><p>A binary ($3\times n_x \times n_y \times n_z$)-tensor called $\Omega_\text{dirichlet}$ which we use to encode the presence of directional homogeneous Dirichlet boundary conditions for every voxel. These boundary conditions determine where the structure is "locked" in place, i.e. where the displacements are fixed at 0. $1$s indicate the presence, and $0$s the absence of homogeneous Dirichlet boundary conditions. Currently, we do not support non-homogeneous Dirichlet boundary conditions (i.e. voxels that have displacements fixed at some value $\neq 0$) since we believe that they are not required for most TO tasks.</p>
</li>
<li><p>A ($1\times n_x \times n_y \times n_z$)-tensor called $\Omega_\text{design}$ containing values $\in \left\lbrace 0,1,-1\right\rbrace$ that we use to encode design space information. We use $0$s and $1$s to constrain voxel densities to be $0$ or $1$, respectively. Entries of $-1$ indicate a lack of density constraints, which signifies that the density in that voxel can be freely optimized.</p>
</li>
<li><p>A ($3\times n_x \times n_y \times n_z$)-tensor called $F$, which encodes external forces given in $\text{N}/\text{m}^3$. The three channels correspond to the force magnitudes in each spacial dimension. For voxels that have external loads assigned to them we automatically enforce the corresponding density value to be $1$.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can manually create a problem object by defining all the required tensors by hand. For example:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># scalar material properties</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">7e10</span> <span class="c1"># Young&#39;s modulus (in Pascal)</span>
<span class="n">ν</span> <span class="o">=</span> <span class="mf">.3</span> <span class="c1"># Poisson&#39;s ratio</span>
<span class="n">σ_ys</span> <span class="o">=</span> <span class="mf">4.5e8</span> <span class="c1"># Yield stress (in Pascal)</span>

<span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># number of voxels in x, y and z direction</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0250</span><span class="p">,</span> <span class="mf">0.0250</span><span class="p">,</span> <span class="mf">0.0250</span><span class="p">]</span> <span class="c1"># spacial dimensions of each voxel in x, y and direction (in meters)</span>

<span class="c1"># define external forces</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">)</span>
<span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">4e7</span> <span class="c1"># external forces (in Newton)</span>

<span class="c1"># define locations of homogeneous Dirichlet conditions</span>
<span class="n">Ω_dirichlet</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">)</span>
<span class="n">Ω_dirichlet</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># define design space</span>
<span class="n">Ω_design</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -1s indicate that these voxels can be freely optimized</span>
<span class="n">Ω_design</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># we set densities to 1 where there are Dirichlet boundary conditions</span>
<span class="n">Ω_design</span><span class="p">[:,:,:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># we set densities to 1 where there are external forces</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can then generate a custom problem object:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.problem</span> <span class="kn">import</span> <span class="n">Problem</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">ν</span><span class="p">,</span> <span class="n">σ_ys</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">Ω_dirichlet</span><span class="p">,</span> <span class="n">Ω_design</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The shape of the problem can be accessed via:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">problem</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>torch.Size([40, 4, 8])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the following, will refer to this specific TO problem as the "ledge" problem.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Three-dimensional-interactive-plotting">Three-dimensional interactive plotting<a class="anchor-link" href="#Three-dimensional-interactive-plotting"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The problem class comes with several useful functionalities. One of them is interactive 3d plotting. We can use it to plot a visualization of our ledge problem:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#output: false</span>
<span class="n">camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
             <span class="n">show_axislabels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">show_ticklabels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/1_dirichlet.png" alt="dirichlet">
<img src="https://dl4to.github.io/dl4to/images/1_design.png" alt="design">
<img src="https://dl4to.github.io/dl4to/images/1_force_locs.png" alt="force_loc">
<img src="https://dl4to.github.io/dl4to/images/1_force_dirs.png" alt="force_dir"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note: Please change the argument <code>display</code> to <code>display=True</code> if you run the experiments on your machine.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As you can see, we have sucessfully created a TO problem that is locked at the right side and is loaded with external forces pushing downwards from above.</p>
<p>We think that our implementation of TO problems is very flexible but also intuitive to use, especially if you have experience with Numpy or PyTorch. While it is possible to generate custom problems in the way described above, you can also load pre-defined problems from one of the datasets that we provide. We will introduce our datasets and dataloaders a bit later in this tutorial. For now, we continue with an introduction of our Solution class.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-Solution-class">The Solution class<a class="anchor-link" href="#The-Solution-class"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Custom-solution-objects">Custom solution objects<a class="anchor-link" href="#Custom-solution-objects"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Objects of this class define solutions to TO problems. They usually result from to application of a TO solver to a problem (we will see that a bit later), but can also be instantiated manually by passing a problem and a density distribution. As an example, we start with a density distribution that contains only zeros:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.solution</span> <span class="kn">import</span> <span class="n">Solution</span>

<span class="n">θ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">)</span>
<span class="n">solution_zeros</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">θ</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, $\theta$ is a ($1\times n_x \times n_y \times n_z$)-tensor that defines a three-dimensional density distribution for the TO problem. Constructing a solution object like this clearly only works if $\theta$ is known. Usually, this is not the case. Nonetheless, it can sometimes be informative to check specific pre-defined densities, like in this example.</p>
<p>The Solution class provides several useful functionalities, again including interactive 3d plotting:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solution_zeros</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
                   <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/1_zero_density.png" alt="zero_density"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we can see, the density distribution $\theta$ has been modified inside of the solution object such that it is not $0$ everywhere anymore. More precisely, it has been adjusted according to the design space information that we prescribed in the problem formulation: We enforced densities of $1$ at certain voxels by setting $\Omega_\text{dirichlet}$ to $1$.</p>
<p>We can check that the density distribution inside of the solution object has indeed been modified and this is not just the visualization:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">solution_zeros</span><span class="o">.</span><span class="n">θ</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">θ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Trivial-solutions">Trivial solutions<a class="anchor-link" href="#Trivial-solutions"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The easiest type of solution is what we call a "trivial solution". The density distribution of a trivial solution in $1$ everywhere, where it is permitted (i.e. where $\Omega_\text{design}$ is not $0$). Together with the zero-density example above this therefore constitutes the simplest solution to a TO problem - we simply choose the thickest possible structure!</p>
<p>Each problem object directly comes with its own trivial solution. It can be accessed via:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">trivial_solution</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">trivial_solution</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The trivial solution is just simply a solution object from the solution class. Therefore, we can also use our plotting functionality on it:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">trivial_solution</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
                      <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/1_trivial_density.png" alt="trivial_density"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Since we do not restrict the density to be $0$ anywhere, the trivial solution is simply a full, solid block. It is interesting to check if this trivial solution actually holds the applied loads and does not break. If this structure would break, applying any TO algorithm would certainly not lead to promising results - because this is already the most solid structure possible.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Solving-the-PDE-for-linear-elasticity">Solving the PDE for linear elasticity<a class="anchor-link" href="#Solving-the-PDE-for-linear-elasticity"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In order to evaluate the stresses we need to solve the partial differential equation (PDE) of linear elasticity. This library comes with its own in-built finite differences method (FDM) solver, which solves the PDE for us. We found handling with finite differences easier than with finite elements. This is attributed to the regular grid structure, which makes the FDM a suitable and intuitive approach. It is however also possible to include custom PDE solvers, e.g., learned PDE solvers - which we will discuss later.</p>
<p>PDE solvers are passed to problem instances:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.pde</span> <span class="kn">import</span> <span class="n">FDM</span>

<span class="n">problem</span><span class="o">.</span><span class="n">pde_solver</span> <span class="o">=</span> <span class="n">FDM</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Passing PDE solvers to problems (instead of passing them to solutions or TO solvers) my seem unintuitive at first, but it comes with several advantages:
First, all solution objects that are derived from this problem will also have access to the PDE solver. The same holds for all TO solver algorithms that we apply to this problem. Second, our implementation automatically constructs most of the PDE system matrix in the background when it is passed to a problem. This saves a lot of time for all future evaluations.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can now use this FDM solver to solve the PDE. This is done via the "solve_pde" command, which returns three tensors:</p>
<ul>
<li>The displacements $u$, which is a ($3\times n_x \times n_y \times n_z$)-tensor.</li>
<li>The stresses $\sigma$, which is a symmetric ($9\times n_x \times n_y \times n_z$)-tensor.</li>
<li>The von Mises stresses $\sigma_\text{vM}$, which is a ($1\times n_x \times n_y \times n_z$)-tensor, i.e., a scalar field.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">σ</span><span class="p">,</span> <span class="n">σ_vm</span> <span class="o">=</span> <span class="n">trivial_solution</span><span class="o">.</span><span class="n">solve_pde</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After the PDE has been solved for a solution, the displacements $u$ are stored inside the solution object and can be accessed via "trivial_solution.u". This avoids solving the same PDE several times.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In order to check if the von Mises stresses are too large, we need to compare its maximum to the yield stress $\sigma_\text{ys}$ of the material:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">σ_vm</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">problem</span><span class="o">.</span><span class="n">σ_ys</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor(0.1321)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Since the fraction returns a value below $1$, this indicates that the structure indees holds the applied forces and does not break!</p>
<p>We can also visualize the spacial distribution of the (normed) displacements and von Mises stresses by passing "solve_pde=True" to the plotting function:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">trivial_solution</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
                      <span class="n">solve_pde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/1_trivial_density_theta.png" alt="trivial_density_theta">
<img src="https://dl4to.github.io/dl4to/images/1_trivial_density_u.png" alt="trivial_density_u">
<img src="https://dl4to.github.io/dl4to/images/1_trivial_density_stress.png" alt="trivial_density_stress"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It is interesting to compare this to the PDE solution that we get from our zero-solution that we defined earlier:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">σ</span><span class="p">,</span> <span class="n">σ_vm</span> <span class="o">=</span> <span class="n">solution_zeros</span><span class="o">.</span><span class="n">solve_pde</span><span class="p">()</span>
<span class="n">σ_vm</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">problem</span><span class="o">.</span><span class="n">σ_ys</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor(1.5208)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Since the value is above $1$, this minimial structure does not hold.</p>
<p>In the three-dimensional visualization we can see that this is especially due to very high von Mises stresses in the top right corner:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solution_zeros</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
                    <span class="n">solve_pde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/1_zero_density_theta.png" alt="zero_density_theta">
<img src="https://dl4to.github.io/dl4to/images/1_zero_density_u.png" alt="zero_density_u">
<img src="https://dl4to.github.io/dl4to/images/1_zero_density_stress.png" alt="zero_density_stress"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There is also the option to use <a href="https://docs.pyvista.org/version/stable/">pyvista</a> for plotting (instead of the default <a href="https://plotly.com/">plotly</a> interface). In the next tutorial, we will show how we can use pyvista for smoother visualizations.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can save and load problem and solution objects via <code>torch.save(problem, "problem.pt")</code> and <code>problem = torch.load("problem.pt")</code>.</p>

</div>
</div>
</div>
</div>
 

