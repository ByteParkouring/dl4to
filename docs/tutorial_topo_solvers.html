---

title: Topo solvers


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/tutorials/3_tutorial_topo_solvers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/tutorials/3_tutorial_topo_solvers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this tutorial you learn how to</p>
<ul>
<li>use optimization criteria as objective functions or as evaluation metrics</li>
<li>use our topo solvers, particularly our SIMP topo solver</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we start actually performing topology optimization!</p>
<p>The TopoSolver class is a parent class that inherits all types of methods for solving TO problems. This contains the famous SIMP method, DL based methods, as well as arbitrary combinations of these two.</p>
<p>In this chapter we start with an introduction of how our optimization pipeline works. For now, we will focus mainly on the SIMP method an we will discuss learned methods in the next tutorial.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Criteria">Criteria<a class="anchor-link" href="#Criteria"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For any topo solver we need to choose an optimization criterion, i.e., an objective function that for which we want to optimize.</p>
<p>For example, let's say we want to minimize the volume of a structure. Depending on what our exact goal is, there are three possible criteria for that:</p>
<ol>
<li>The volume criterion. This criterion simply sums up all values in the density distribution.</li>
<li>The volume fraction criterion. This criterion returns the volume of the structure divided by the total number of voxels, i.e. the average density. This has the advantage that it always returns a value between $0$ and $1$.</li>
<li>The volume constraint criterion. This criterion compares the volume fraction wit a pre-defined maximum volume fraction. If the difference is negative (i.e., the current volume is below the maximum volume fraction) then this criterion returns $0$, otherwise it returns a positive output. The thresholding is done by either a ReLU function, or a Softplus function for more smoothness.</li>
</ol>
<p>Our library contains many more criteria that can be used for evaluation or as loss/objective functions. We will refer to some of them in the next tutorial on trainable topo solvers. For now, we will use the volume fraction and the stress constraint criterion for SIMP. The stress constraint criterion has a similar concept like the volume constraint criterion: We compare the current maximal von Mises stress with the yield stress and we get an output $&gt;0$ if the von Mises stress is larger than the yield stress.</p>
<p>We weight the StressConstraint accordingly. Unfortunately, the SIMP algorithm - like most algorithms - needs some sort of finetuning that is done manually, usually by trial-end-error. We found that a constant of $10^{-11}$ works well for this example.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">VolumeFraction</span><span class="p">,</span> <span class="n">StressConstraint</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">VolumeFraction</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1e-11</span> <span class="o">*</span> <span class="n">StressConstraint</span><span class="p">(</span><span class="n">threshold_fct</span><span class="o">=</span><span class="s1">&#39;softplus&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For our TO problem we choose the ledge problem introduced in the last tutorials, and we pass an FDM solver to it:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.datasets</span> <span class="kn">import</span> <span class="n">BasicDataset</span>
<span class="kn">from</span> <span class="nn">dl4to.pde</span> <span class="kn">import</span> <span class="n">FDM</span>

<span class="n">problem</span> <span class="o">=</span> <span class="n">BasicDataset</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">ledge</span><span class="p">(</span><span class="n">force_per_area</span><span class="o">=-</span><span class="mf">1e6</span><span class="p">)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">pde_solver</span> <span class="o">=</span> <span class="n">FDM</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-SIMP-method">The SIMP method<a class="anchor-link" href="#The-SIMP-method"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Solid Isotropic Material with Penalization (SIMP) method is widely regarded as the most significant classical approach used in TO. SIMP employs an iterative optimization scheme to improve structural performance by adjusting voxel densities. See Algorithm 1 for a full breakdown of the steps that are part of the SIMP algorithm:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/3_simp.png" alt="title"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For now, we don't really need to know how the algorithm works exactly. We can initialize SIMP as follows:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.topo_solvers</span> <span class="kn">import</span> <span class="n">SIMP</span>

<span class="n">simp</span> <span class="o">=</span> <span class="n">SIMP</span><span class="p">(</span>
    <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
    <span class="n">n_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">binarizer_steepening_factor</span><span class="o">=</span><span class="mf">1.06</span><span class="p">,</span>
    <span class="n">lr</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-apply-topo-solvers-to-a-TO-problem">How to apply topo solvers to a TO problem<a class="anchor-link" href="#How-to-apply-topo-solvers-to-a-TO-problem"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In order to apply a topo_solver to a problem, we can simply call it via</p>

<pre><code>solution = topo_solver(problem),

</code></pre>
<p>which returns a solution object. This also works with a list of problems as input, in which case topo solver likewise returns a list of solutions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solution</span> <span class="o">=</span> <span class="n">simp</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's take a look at the solution of the SIMP algorithm:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">solution</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
              <span class="n">solve_pde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/3_density.png" alt="density">
<img src="https://dl4to.github.io/dl4to/images/3_displacements.png" alt="displacements">
<img src="https://dl4to.github.io/dl4to/images/3_stresses.png" alt="stresses"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the output of the SIMP algorithm returns indeed a plausible solution to the TO problem.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can check the volume fraction of this solution via the following:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">volume_fraction</span> <span class="o">=</span> <span class="n">VolumeFraction</span><span class="p">()</span>
<span class="n">solution</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">volume_fraction</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.4208], grad_fn=&lt;DivBackward0&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We also implemented a "Binariness" criterion which determines how binary the solution is. A value of $1$ means that it is fully binary, while a lower value signifies many values that are not near $0$ or $1$.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">Binariness</span>

<span class="n">binariness</span> <span class="o">=</span> <span class="n">Binariness</span><span class="p">()</span>
<span class="n">solution</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">binariness</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.9989])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The binariness score is very high, which confirms the impression that we get from the 3d plot above.</p>

</div>
</div>
</div>
</div>
 

