---

title: Topo solvers


keywords: fastai
sidebar: home_sidebar



nb_path: "notebooks/tutorials/3_tutorial_topo_solvers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/tutorials/3_tutorial_topo_solvers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In this tutorial you learn how to</p>
<ul>
<li>use optimization criteria as objective functions or as evaluation metrics</li>
<li>use our topo solvers, particularly our SIMP topo solver</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we start actually performing topology optimization!</p>
<p>The TopoSolver class is a parent class that inherits all types of methods for solving TO problems. This contains the famous SIMP method, DL based methods, as well as arbitrary combinations of these two.</p>
<p>In this chapter we start with an introduction of how our optimization pipeline works. For now, we will focus mainly on the SIMP method an we will discuss learned methods in the next tutorial.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Criteria">Criteria<a class="anchor-link" href="#Criteria"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For any topo solver we need to choose an optimization criterion, i.e., an objective function that for which we want to optimize. Our library contains many criteria that can be used for evaluation or as loss/objective functions. Generally speaking, we have two different types of criteria: supervised and unsupervised.</p>
<ul>
<li>Supervised criteria compare a given solution to a ground truth solution. This for instance contains common loss functions like the "binary cross entropy" (BCE) function as well as many commonly used evaluation criteria for semantic segmentation, like the "Intersection over Union" (IoU) and "Dice". </li>
<li>Unsupervised criteria don't require a ground truth and evaluates inputs based on their intrinsic properties. This includes criteria for volume, maximal stress and compliance.</li>
</ul>
<p>We will use some of the mentioned criteria in this and in the next tutorial on trainable topo solvers.</p>
<p>For SIMP, we use compliance minimization with a volume constraint:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">Compliance</span><span class="p">,</span> <span class="n">VolumeConstraint</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">Compliance</span><span class="p">()</span> <span class="o">+</span> <span class="n">VolumeConstraint</span><span class="p">(</span><span class="n">max_volume_fraction</span><span class="o">=</span><span class="mf">.12</span><span class="p">,</span> <span class="n">threshold_fct</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Compliance is a very common objective in topology optimization. It is defined as the product of external forces and displacements. The <a href="/dl4tounsupervised_criteria.html#VolumeConstraint"><code>VolumeConstraint</code></a> criterion compares the volume fraction -- i.e., the average voxel density -- wit a pre-defined maximum volume fraction (which in this case is 0.12). If the difference is negative (i.e., the current volume is below the maximum volume fraction) then this criterion returns 0, otherwise it returns a positive output. The thresholding can be done via either a ReLU function or a Softplus function. Both <a href="/dl4tounsupervised_criteria.html#Compliance"><code>Compliance</code></a> and <a href="/dl4tounsupervised_criteria.html#VolumeConstraint"><code>VolumeConstraint</code></a> are unsupervised criteria.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For our TO problem we choose the first sample of the disc complex SELTO dataset and we pass a FDM solver to it:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.datasets</span> <span class="kn">import</span> <span class="n">SELTODataset</span>
<span class="kn">from</span> <span class="nn">dl4to.pde</span> <span class="kn">import</span> <span class="n">FDM</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">SELTODataset</span><span class="p">(</span><span class="s2">&quot;/localdata/dl4to_dataset&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;disc_complex&#39;</span><span class="p">)</span>
<span class="n">problem</span><span class="p">,</span> <span class="n">gt_solution</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">problem</span><span class="o">.</span><span class="n">pde_solver</span> <span class="o">=</span> <span class="n">FDM</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Found 7337 files.
importing dataset...
done!
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-SIMP-method">The SIMP method<a class="anchor-link" href="#The-SIMP-method"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Solid Isotropic Material with Penalization (SIMP) method is widely regarded as the most significant classical approach used in TO. SIMP employs an iterative optimization scheme to improve structural performance by adjusting voxel densities. See Algorithm 1 for a full breakdown of the steps that are part of the SIMP algorithm:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://dl4to.github.io/dl4to/images/3_simp.png" alt="title"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We initialize SIMP as follows, with a learning rate of 0.3:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.topo_solvers</span> <span class="kn">import</span> <span class="n">SIMP</span>

<span class="n">simp</span> <span class="o">=</span> <span class="n">SIMP</span><span class="p">(</span>
    <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
    <span class="n">binarizer_steepening_factor</span><span class="o">=</span><span class="mf">1.02</span><span class="p">,</span>
    <span class="n">n_iterations</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
    <span class="n">lr</span><span class="o">=</span><span class="mf">3e-1</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="How-to-apply-topo-solvers-to-a-TO-problem">How to apply topo solvers to a TO problem<a class="anchor-link" href="#How-to-apply-topo-solvers-to-a-TO-problem"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In order to apply a topo_solver to a problem, we can simply call it via</p>

<pre><code>solution = topo_solver(problem),

</code></pre>
<p>which returns a solution object. This also works with a list of problems as input, in which case topo solver likewise returns a list of solutions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">solution</span> <span class="o">=</span> <span class="n">simp</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's take a look at the solution of the SIMP algorithm:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">camera_position</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.06</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">)</span>
<span class="n">solution</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">camera_position</span><span class="o">=</span><span class="n">camera_position</span><span class="p">,</span>
              <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">solve_pde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/dl4toimages/3_density_disc.png" alt="density">
<img src="/dl4toimages/3_displacements_disc.png" alt="displacements">
<img src="/dl4toimages/3_stresses_disc.png" alt="stresses"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We see that the output of the SIMP algorithm returns indeed a plausible solution to the TO problem.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can observe that the volume fraction of the SIMP solution is exactly 0.12:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">VolumeFraction</span>

<span class="n">volume_fraction</span> <span class="o">=</span> <span class="n">VolumeFraction</span><span class="p">()</span>
<span class="n">volume_fraction</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.1200], grad_fn=&lt;DivBackward0&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With DL4TO we provide an unsupervised criterion called <a href="/dl4tounsupervised_criteria.html#Binariness"><code>Binariness</code></a> which determines how binary the solution is. A value of $1$ means that it is fully binary, while a lower value signifies many values that are not near $0$ or $1$. We see that our solution is almost fully binary:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">Binariness</span>

<span class="n">binariness</span> <span class="o">=</span> <span class="n">Binariness</span><span class="p">()</span>
<span class="n">binariness</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.9164])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As we can observe from the above 3D plot, the von Mises stresses are well below the yield stress. The <a href="/dl4tounsupervised_criteria.html#MaxStress"><code>MaxStress</code></a> criterion confirms this with a normalized maximal stress of only a quarter of the maximum value of 1:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">dl4to.criteria</span> <span class="kn">import</span> <span class="n">MaxStress</span>

<span class="n">max_stress</span> <span class="o">=</span> <span class="n">MaxStress</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">max_stress</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>tensor([0.2563], grad_fn=&lt;DivBackward0&gt;)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

