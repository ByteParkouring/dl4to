# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/preprocessing/2_solution_preprocessing.ipynb (unless otherwise specified).

__all__ = ['Preprocessing', 'CombinedPreprocessing', 'ProblemPreprocessing', 'TrivialPreprocessing',
           'ForcePreprocessing', 'ConvexHullPreprocessing', 'SolutionPreprocessing', 'PDEPreprocessing',
           'DensityPreprocessing']

# Internal Cell
import torch
from typing import Union

# Cell
class Preprocessing():
    """
    A parent class for all data preprocessing strategies.
    """
    def __init__(self,
                 preprocessing_type:str, # The type of the preprocessing, which can either be "problem" or "solution". Problem preprocessing preprocesses the data based on problem information like forces etc., while solution preprocessing uses solution specific information like stresses, densities etc.
                 name:str=None, # The name of the preprocessing.
                 normalize:bool=False # Whether to normalize the output of the preprocessing.
                ):
        self.preprocessing_type = preprocessing_type
        self.name = name
        self._normalize = normalize
        self._shape = self._get_shape()
        self._vector_directions = self._get_vector_directions()
        assert len(self.vector_directions) == self.shape


    @property
    def normalize(self):
        return self._normalize


    @property
    def shape(self):
        return self._shape


    @property
    def vector_directions(self):
        return self._vector_directions


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing and returns a `torch.Tensor` object.
        """
        raise NotImplementedError("Must be overridden.")


    def _get_shape(self):
        raise NotImplementedError("Must be overridden.")


    def _get_vector_directions(self):
        raise NotImplementedError("Must be overridden.")


    def __add__(self,
                preprocessing:"dl4to.preprocessing.Preprocessing" # The preprocessing that should be added to the current one.
               ):
        """
        Summation of two preprocessings results in a new combined preprocessing that concatenates the output of both. Returns a `dl4to.preprocessing.CombinedPreprocessing` object.
        """
        return CombinedPreprocessing(self, preprocessing)

# Cell
class CombinedPreprocessing(Preprocessing):
    """
    A class that results from the summation of two criteria.
    """
    def __init__(self,
                 preprocessing1:"dl4to.preprocessing.Preprocessing", # The first preprocessing.
                 preprocessing2:"dl4to.preprocessing.Preprocessing", # The second preprocessing.
                ):
        self.preprocessing1 = preprocessing1
        self.preprocessing2 = preprocessing2
        name = f"{preprocessing1.name}_plus_{preprocessing2.name}"
        preprocessing_type = f"{preprocessing1.preprocessing_type}_plus_{preprocessing2.preprocessing_type}"
        super().__init__(preprocessing_type=preprocessing_type, name=name)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies both preprocessing to a problem or solution object and performs channel-wise concatenation of their outputs. Returns a `torch.Tensor` object.
        """
        output1 = self.preprocessing1(problem_or_solution)
        output2 = self.preprocessing2(problem_or_solution)
        return torch.cat([output1, output2], dim=1)


    def _get_shape(self):
        return self.preprocessing1.shape + self.preprocessing2.shape


    def _get_vector_directions(self):
        return self.preprocessing1.vector_directions + self.preprocessing2.vector_directions

# Internal Cell
import torch
import warnings
from skimage.morphology import convex_hull_image
from typing import Union

from .preprocessing import Preprocessing
from .utils import cast_to_problem

# Cell
class ProblemPreprocessing(Preprocessing):
    """
    A parent class for several problem preprocessing strategies.
    Problem preprocessing processes the data based on problem specific information like forces and boundary conditions.
    """
    def __init__(self,
                 name:str=None, # The name of the preprocessing.
                 normalize:bool=False # Whether to normalize the output of the preprocessing.
                ):
        super().__init__(preprocessing_type='problem',
                         name=name,
                         normalize=normalize)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a solution object is passed, then it is automatically converted to a problem object via `solution.problem`.

        """
        raise NotImplementedError("Must be overridden.")

# Cell
class TrivialPreprocessing(ProblemPreprocessing):
    """
    The output of trivial preprocessing [1] is a 7-channel tensor which results from the channel-wise concatenation of Dirichlet boundary conditions, design space information and loads.
    It is possible to normalize each sample’s F via the infinity norm over all forces in a dataset.
    """
    def __init__(self,
                 normalize:bool=False, # Whether to normalize the forces in the output of the preprocessing. If True, then a dataset is required.
                 dataset:"dl4to.datasets.TopoDataset"=None # A dataset that is used for the normalization of the forces in the output of the preprocessing. Is only used if `normalize=True`.
                ):
        super().__init__(name="trivial_preprocessing", normalize=normalize)
        self.L_inf_norm_F = 1.
        if self.normalize:
            if dataset is None:
                warnings.warn("Batch normalization is only possible if a dataset is provided.")
                self._normalize = False
            else:
                self.set_normalization_constant(dataset)


    def set_normalization_constant(self, dataset):
        max_forces = []
        for i in range(len(dataset)):
            problem, _ = dataset[i]
            max_forces.append(problem.F.abs().max())

        if len(max_forces) == 0:
            return 1
        self.L_inf_norm_F = sum(max_forces) / len(max_forces)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a solution object is passed, then it is automatically converted to a problem object via `solution.problem`.
        """
        problem = cast_to_problem(problem_or_solution)
        F = problem.F / self.L_inf_norm_F
        return torch.cat([problem.Ω_dirichlet, problem.Ω_design, F]).unsqueeze(0)


    def _get_shape(self):
        return 7


    def _get_vector_directions(self):
        return [None, None, None, None, 'x', 'y', 'z']

# Cell
class ForcePreprocessing(ProblemPreprocessing):
    """
    The input of the neural network is the 3-channel force tensor F.
    It is possible to normalize each sample’s F via the mean absolute maximum over a dataset.
    """
    def __init__(self,
                 normalize:bool=False, # Whether to normalize the forces in the output of the preprocessing. If True, then a dataset is required.
                 dataset:"dl4to.datasets.TopoDataset"=None # A dataset that is used for the normalization of the forces in the output of the preprocessing. Is only used if `normalize=True`.
                ):
        super().__init__(name="force_preprocessing", normalize=normalize)
        self.L_inf_norm_F = 1.
        if self.normalize:
            if dataset is None:
                warnings.warn("Batch normalization is only possible if a dataset is provided.")
                self._normalize = False
            else:
                self.set_normalization_constant(dataset)


    def set_normalization_constant(self, dataset):
        max_forces = []
        for problem, _ in dataset:
            max_forces.append(problem.F.abs().max())
        if len(max_forces) == 0:
            return 1
        self.L_inf_norm_F = sum(max_forces) / len(max_forces)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a solution object is passed, then it is automatically converted to a problem object via `solution.problem`.
        """
        problem = cast_to_problem(problem_or_solution)
        F = problem.F / self.L_inf_norm_F
        return F.unsqueeze(0)


    def _get_shape(self):
        return 3


    def _get_vector_directions(self):
        return ['x', 'y', 'z']

# Cell
class ConvexHullPreprocessing(ProblemPreprocessing):
    """
    The convex hull of a binary image is the set of pixels included in the smallest convex polygon that surround all white pixels in the input.
    Convex hull preprocessing [1] generalizes this to 3d voxels and constructs a polygon with density 1 that connects the force allocation points to points with homogeneous Dirichlet boundary conditions.
    This binary density polygon is the output of this preprocessing.

    """
    def __init__(self):
        super().__init__(name="convex_hull_preprocessing")


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a solution object is passed, then it is automatically converted to a problem object via `solution.problem`.
        """
        problem = cast_to_problem(problem_or_solution)
        Ω_design = problem.Ω_design
        θ = (Ω_design == 1).type(torch.float32)
        assert len(θ.shape) == 4, f"{θ.shape=}"
        θ = torch.tensor(convex_hull_image(θ[0].numpy()))
        θ = θ.unsqueeze(0)
        assert len(θ.shape) == 4, f"{θ.shape=}"
        return θ.unsqueeze(0).type(torch.float32)


    def _get_shape(self):
        return 1


    def _get_vector_directions(self):
        return [None]

# Internal Cell
import torch
import warnings
from typing import Union

from .preprocessing import Preprocessing
from .utils import cast_to_solution

# Cell
class SolutionPreprocessing(Preprocessing):
    """
    A parent class for several solution preprocessing strategies.
    Solution preprocessing processes the data based on solution specific information like stresses, displacements and densities.
    """
    def __init__(self,
                 name:str=None, # The name of the preprocessing.
                 normalize:bool=False # Whether to normalize the output of the preprocessing.
                ):
        super().__init__(preprocessing_type='solution',
                         name=name,
                         normalize=normalize)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a problem object is passed, then it is automatically converted to its trivial solution via `problem.trivial_solution`.
        """
        raise NotImplementedError("Must be overridden.")

# Cell
class PDEPreprocessing(SolutionPreprocessing):
    """
    PDE preprocessing [1, 2] computes the von Mises stresses for the trivial solution. We normalize the resulting tensor with $20\%$ of the yield stress to obtain outputs that are likely close to the unit interval.
    These initial von Mises stresses are then used as a $1$-channel input to the neural network. It is also possible to use the displacements $u$ as input, or a concatenation of $u$ and $\sigma_{vM}$.
    We found that using the von Mises stresses $\sigma_{vM}$ is usually enough.
    """
    def __init__(self,
                 use_u:bool=False, # Whether to use the displacements in the preprocessing.
                 use_σ_vm:bool=True, # Whether to use the von Mises stresses in the preprocessing.
                 normalize:bool=False # Whether to normalize the forces in the output of the preprocessing. If True, then a dataset is required.
                ):
        self.use_u = use_u
        self.use_σ_vm = use_σ_vm
        if not any([self.use_u, self.use_σ_vm]):
            warnings.warn("At least one of `use_u` and `use_σ_vm` must be True.")
        super().__init__(name = "pde_preprocessing", normalize=normalize)


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a problem object is passed, then it is automatically converted to its trivial solution via `problem.trivial_solution`.
        """
        solution = cast_to_solution(problem_or_solution)
        u, _, σ_vm = solution.solve_pde()
        if self.normalize:
            σ_vm = σ_vm.clone() / .2 * solution.problem.σ_ys
            u = 1e2 * u.clone()
        output = []
        if self.use_u:
            output.append(u)
        if self.use_σ_vm:
            output.append(σ_vm)
        return torch.cat(output, dim=0).unsqueeze(0)


    def _get_shape(self):
        return 3 * self.use_u + self.use_σ_vm


    def _get_vector_directions(self):
        return ['x', 'y', 'z'] * self.use_u + [None] * self.use_σ_vm

# Cell
class DensityPreprocessing(SolutionPreprocessing):
    """
    A preprocessing that simply returns the density distribution of the solution objects as outputs.
    """
    def __init__(self,
                 binary:bool=False, # Whether the density should be binarized.
                 normalize:bool=False # Whether to normalize the output of the preprocessing.
                ):
        super().__init__(name="density_preprocessing", normalize=normalize)
        self.binary = binary


    def __call__(self,
                 problem_or_solution:Union["dl4to.problem.Problem","dl4to.solution.Solution"] # A problem or solution object.
                ):
        """
        Applies the preprocessing to a problem or solution object. Returns a `torch.Tensor` object.
        If a problem object is passed, then it is automatically converted to its trivial solution via `problem.trivial_solution`.
        """
        solution = cast_to_solution(problem_or_solution)
        return solution.get_θ(binary=self.binary).unsqueeze(0)


    def _get_shape(self):
        return 1


    def _get_vector_directions(self):
        return [None]