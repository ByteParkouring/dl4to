# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/density_representers/3_deep_image_prior_density_representer.ipynb (unless otherwise specified).

__all__ = ['DensityRepresenter', 'FilteringDensityRepresenter', 'filter_fcts', 'DeepImagePriorDensityRepresenter']

# Internal Cell
import math
import torch

# Cell
class DensityRepresenter(torch.nn.Module):
    """
    A parent class that inherits different density representers. A density representer has a latent density distribution that is for instance used in the optimization steps of SIMP.
    Additionally, it can be employed for neural reparamterization. Additionally, the density representer has an in-built binarizer, that can be interpreted as a smoothed Heaviside function.
    The binarizer returns densities that have values closer to 0 and 1.
    """
    def __init__(self,
                 problem:"dl4to.problem.Problem"=None, # The problem object for which the density representer is used. The problem object is necessary to grant that boundary and design space constraints are fulfilled. However, the problem does not need to be passed during initializiaton but can also be passed later by overriding `density_representer.problem`.
                 binarizer_strength:float=1. # The steepness of the smoothed Heaviside-function. A binarizer strength of infinity would corresponds to a non-smooth classical Heaviside step function.
                ):
        super().__init__()
        self.binarizer_strength = binarizer_strength
        self.binarizer_strength_init = binarizer_strength
        self.problem = problem


    def _setup_for_problem(self):
        pass


    @property
    def problem(self):
        return self._problem


    @problem.setter
    def problem(self, problem):
        self._problem = problem
        if self.problem is not None:
            self._setup_for_problem()
            self.reset_binarizer()


    def _apply_density_representer(self):
        raise NotImplementedError("Must be overridden.")


    def _apply_binarizer(self, θ):
        η = .5
        β = self.binarizer_strength
        numerator = math.tanh(β * η) + torch.tanh(β * (θ - η))
        divisor   = math.tanh(β * η) +  math.tanh(β * (1 - η))
        return numerator / divisor


    def steepen_binarizer(self,
                          binarizer_steepening_factor:float=1.1 # The factor by which to change the current binarizer strength. A value of 1. means that the binarizer does not change.
                         ):
        """
        Increases the binarizer strength by a factor.
        """
        self.binarizer_strength *= binarizer_steepening_factor


    def reset_binarizer(self):
        """
        Resets the binarizer strength to its initial value.
        """
        self.binarizer_strength = self.binarizer_strength_init


    def __call__(self):
        """
        Applies the density representer to the latent density representation, followed by the binarizer step and a projection step.
        The projection step makes sure that the problem conditions are fulfilled and that the density has no values outside of the unit interval.
        Returns a flattened `torch.Tensor` containing the density distribution.
        """
        θ = self._apply_density_representer()
        if not (torch.all(0 <= θ) and torch.all(θ <= 1)):
            raise ValueError("The function DensityRepresenter_density_representer is only allowed to produce values in [0, 1].")

        θ = self._apply_binarizer(θ)
        θ[self.problem.Ω_design == 0] = 0.
        θ[self.problem.Ω_design == 1] = 1.

        return θ.clamp(0, 1)

# Internal Cell
import torch

from .density_representers import DensityRepresenter
from .density_filters import UniformDensityFilter, RadialDensityFilter, MaxPoolDensityFilter
import warnings

# Cell

filter_fcts = ['radial', 'uniform', 'max_pool', None]

class FilteringDensityRepresenter(DensityRepresenter):
    """
    A density representer that applies filtering to its latent density distribution.
    """
    def __init__(self,
                 problem:"dl4to.problem.Problem"=None, # The problem object for which the density representer is used. The problem object is necessary to grant that boundary and design space constraints are fulfilled. However, the problem does not need to be passed during initializiaton but can also be passed later by overriding `density_representer.problem`.
                 filter_size:int=3, # The size of the filter kernel.
                 filter_fct:str='radial', # The type of filtering strategy that is used. Possible options are "radial", "uniform", "max_pool" and None.
                 binarizer_strength:float=1., #  The steepness of the smoothed Heaviside-function. A binarizer strength of infinity would corresponds to a non-smooth classical Heaviside step function.
                 θ_default:float=.5 # The weighting factor for the trivial solution density that is used as the initialization of the latent density distribution.
                ):
        super().__init__(
            problem=problem,
            binarizer_strength=binarizer_strength
        )
        self.filter_size = filter_size
        self.filter_fct = filter_fct
        assert self.filter_fct in filter_fcts
        self.θ_default = θ_default


    def _setup_filter(self):
        if self.filter_fct == 'radial':
            self.filter = RadialDensityFilter(filter_size=self.filter_size, dtype=self.problem.dtype)
        elif self.filter_fct == 'uniform':
            self.filter = UniformDensityFilter(filter_size=self.filter_size, dtype=self.problem.dtype)
        elif self.filter_fct == 'max_pool':
            self.filter = MaxPoolDensityFilter(filter_size=self.filter_size, dtype=self.problem.dtype)
        else:
            self.filter = lambda θ: θ


    def _setup_for_problem(self):
        θ = torch.ones(1, *self.problem.shape, dtype=self.problem.dtype) * self.θ_default
        self.θ = torch.nn.Parameter(θ, requires_grad=True)
        self._setup_filter()


    def _apply_density_representer(self):
        self.θ.data.clamp_(0, 1)

        self.θ.data[self.problem.Ω_design == 0] = 0.
        self.θ.data[self.problem.Ω_design == 1] = 1.

        θ = self.filter(self.θ.unsqueeze(0)).squeeze(0)

        if θ.max().item() > 1.1 or θ.min().item() < -0.1:
            warnings.warn("Density value is too large or too small")

        return θ.clamp(0, 1)

# Internal Cell
import torch

from .models import DeepImagePrior
from .density_representers import DensityRepresenter

# Cell
class DeepImagePriorDensityRepresenter(DensityRepresenter):
    """
    A density representer that contains a DIP module and performs a forward pass with a noise input when being called. The idea is adapted from [1].
    """
    def __init__(self,
                 problem:"dl4to.problem.Problem"=None, # The problem object for which the density representer is used. The problem object is necessary to grant that boundary and design space constraints are fulfilled. However, the problem does not need to be passed during initializiaton but can also be passed later by overriding `density_representer.problem`.
                 binarizer_strength:float=1. # The steepness of the smoothed Heaviside-function. A binarizer strength of infinity would corresponds to a non-smooth classical Heaviside step function.
                ):
        super().__init__(
            problem=problem,
            binarizer_strength=binarizer_strength
        )


    def _setup_for_problem(self):
        self.dip = DeepImagePrior(self.problem.shape)


    def _apply_density_representer(self):
        return self.dip()